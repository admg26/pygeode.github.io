=========================
Variable input and output
=========================

.. currentmodule:: pygeode

Reading from files
------------------

PyGeode was intended for dealing with large gridded datasets - nearly always
such datasets will be serialized on disk, sometimes in a single file, but often
spread over many files. While PyGeode supports NetCDF files most natively, the
commands for loading and saving data to disk are to a large extend independent
of the format used, and attempts are made to automatically detect which format
you are working with. 

The most basic form of reading a single file from disk is to simply call :meth:`open`. We'll open
the file written out at the end of the :doc:`gettingstarted` section of the tutorial:

.. ipython::

  In [0]: import pygeode as pyg, numpy as np

  In [0]: ds = pyg.open('file.nc')

  In [0]: print ds

As you can see, this returns a :class:`Dataset` object with the contents of the
file. The format of the file has been automatically detected. In this case the
netcdf file was generated by an eariler call to :meth:`save`, which fills in
metadata recognized by PyGeode that indicate, for instance, what kind of
PyGeode axis each NetCDF dimension coresponds to.

..

  $ ncdump -h file.nc
  netcdf file {
  dimensions:
    lat = 31 ;
    lon = 60 ;
  variables:
    double lat(lat) ;
      lat:units = "degrees_north" ;
      lat:standard_name = "latitude" ;
      lat:ancillary_variables = "lat_weights" ;
      lat:axis = "Y" ;
    double lon(lon) ;
      lon:units = "degrees_east" ;
      lon:standard_name = "longitude" ;
      lon:axis = "X" ;
    double Temp(lat, lon) ;
    double lat_weights(lat) ;

  // global attributes:
      :history = "Synthetic Temperature data generated by pygeode" ;
  }

multifile interpolation

Saving to files
---------------
naming considerations, attributes

Constructing variables in memory
--------------------------------

It is also often useful to create PyGeode variables directly in memory; for
instance, to evaluate analytical expressions on a given geophysical grid. A very
useful set of building blocks for creating variables in this way are axes
objects. If you already have a variable on the relevant grid (defined from a
file for instance), it's easy to simply use the existing axes, as has been done
in many cases in these tutorials. However, most axes objects have simple
constructors to create them directly.

.. ipython::

  # The simplest, default case
  In [1]: print pyg.NamedAxis(np.arange(15), 'myaxis')

  # Some simple examples
  In [1]: lon = pyg.Lon(180)
  
  In [1]: print lon

  In [2]: lat = pyg.Lat(92)

  In [2]: print lat

  In [3]: pres = pyg.Pres([1000, 900, 800, 700, 500, 300, 200, 100, 50, 30, 10])

  # Gaussian latitudes (with appropriate weights)
  In [2]: lat2 = pyg.gausslat(64)

  In [2]: print lat2

Time axes are somewhat more complicated, as you need to specify the calendar,
the reference date (``startdate``), offsets, and the native unit:

.. ipython::

  In [2]: time = pyg.ModelTime365(values=np.arange(3650), units='days', startdate=dict(year=2000, month=1))

Usually the easiest approach to creating variables in memory is to apply the
relevant mathematical operations to the axes themselves:

.. ipython::

  In [2]: pyg.sin(2*np.pi*time / 365) * pyg.exp(-(lat2 / 20.)**2) 

  In [2]: pyg.sin(2*np.pi*time / 365) * pyg.exp(-(lat2 / 20.)**2)

However, if you have a numpy array that you want to turn in to a PyGeode
variable, this can also be done.

.. ipython::

  In [2]: x = np.ones((64, 180), 'd')

  In [3]: print pyg.Var((lat2, lon), name = 'myvar', values=x)

